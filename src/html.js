const parse5 = require('parse5');

const helpers = require('./helpers.js');

/**
 * Helper function used when you want to console.log(JSON.stringify(document)).
 *
 * @param  {object} document  An HTML AST
 * @return {object}           Modified AST
 */
function cleanDocument (document) {
  /**
   * Parent nodes are circular and don't allow you to JSON.stringify.
   * This function removes them.
   *
   * @param  {object}    node  A node in the HTML AST
   * @return {undefined}       Does not return anything, just mutates the object
   */
  function removeParentNodes (node) {
    delete node.parentNode;
    // Coverage ignored because this function is only used during development.
    /* istanbul ignore next */
    if (node.childNodes) {
      /* istanbul ignore next */
      node.childNodes.forEach(function (child) {
        /* istanbul ignore next */
        removeParentNodes(child);
      });
    }
  }
  removeParentNodes(document);

  return document;
}
cleanDocument({});

/**
 * Parse an HTML string.
 * Replace the original classnames with the atomized versions.
 * Reserialize HTML to string.
 *
 * @param  {object} options   Options object from user containing verbose/customLogger
 * @param  {string} input     String of valid HTML
 * @param  {object} classMap  Map generated by css.js containing class names as the key with array of atomized style class name strings as the value
 * @return {string}           String of HTML with the class names replaced
 */
const html = function (options, input, classMap) {
  options = options || {};
  input = input || '';
  classMap = classMap || {};

  // String => Object
  const document = cleanDocument(parse5.parse(input));

  /**
   * Finds and removes every instance of a value from an array
   *
   * @param  {Array} arr    Any array
   * @param  {any}   value  Any literal that can be compared with ===
   * @return {Array}        The mutated array
   */
  function removeEveryInstance (arr, value) {
    let i = 0;
    while (i < arr.length) {
      if (arr[i] === value) {
        arr.splice(i, 1);
      } else {
        ++i;
      }
    }
    return arr;
  }

  /**
   * Replaces all instances of a class name in class attributes in the DOM
   * with its atomized representation of class names.
   *
   * @param {object}     node            An HTML AST node
   * @param {string}     classToReplace  A string to find and replace
   * @param {Array}      newClasses      Array of strings that will replace the given class
   * @param {string}     tag             HTML tag name ('h1', 'section', 'footer', etc)
   * @return {undefined}                 Just mutates the AST. Nothing returned
   */
  function replaceSemanticClassWithAtomizedClasses (node, classToReplace, newClasses, tag) {
    if (node.attrs) {
      // console.log(node);
      // classToReplace
      // node.tagName
      node.attrs.forEach(function (attribute) {
        if (attribute.name === 'class') {
          let classes = attribute.value.split(' ');

          if (classes.includes(classToReplace)) {
            if (!tag || node.tagName === tag) {
              classes = removeEveryInstance(classes, classToReplace);
              classes.push(...newClasses);
            }
          }
          attribute.value = classes.join(' ');
        }
      });
    }
    if (node.childNodes) {
      node.childNodes.forEach(function (child) {
        replaceSemanticClassWithAtomizedClasses(child, classToReplace, newClasses, tag);
      });
    }
  }

  Object.keys(classMap).forEach(function (semanticClass) {
    let atomizedClasses = classMap[semanticClass];
    atomizedClasses = atomizedClasses.map(function (atomic) {
      return atomic.replace('.', '');
    });

    let tag = '';
    if (semanticClass.startsWith('.')) {
      semanticClass = semanticClass.replace('.', '');
    } else {
      const classAndTag = semanticClass.split('.');
      tag = classAndTag[0];
      semanticClass = classAndTag[1];
    }
    replaceSemanticClassWithAtomizedClasses(document, semanticClass, atomizedClasses, tag);
  });

  // Object => string
  let markup = parse5.serialize(document);

  if (!markup || markup === '<html><head></head><body></body></html>') {
    helpers.throwError(options, 'Error parsing HTML', (markup || document));
  }

  return markup;
};

module.exports = html;
